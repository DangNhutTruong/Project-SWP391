console.log('üöÄ Kh·ªüi ƒë·ªông Backend API Server v·ªõi MySQL v√† JWT...');

const express = require('express');
const mysql = require('mysql2/promise');
const cors = require('cors');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

const app = express();
const PORT = 5000;
const JWT_SECRET = 'your-super-secret-jwt-key-for-quit-smoking-app-2025';

// Middleware
app.use(cors());
app.use(express.json());

console.log('‚úÖ Setup middleware th√†nh c√¥ng');

// MySQL connection pool
const pool = mysql.createPool({
  host: '127.0.0.1',
  port: 3306,
  user: 'root',
  password: '12345',
  database: 'SmokingCessationDB',
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0
});

// Test MySQL connection
(async () => {
  try {
    await pool.query('SELECT 1');
    console.log('‚úÖ MySQL k·∫øt n·ªëi th√†nh c√¥ng!');
    
    // Ki·ªÉm tra v√† th√™m d·ªØ li·ªáu m·∫´u n·∫øu c·∫ßn thi·∫øt
    try {
      await insertSampleDataIfNeeded();
      console.log('‚úÖ ƒê√£ ki·ªÉm tra v√† th√™m d·ªØ li·ªáu m·∫´u (n·∫øu c·∫ßn)');
    } catch (sampleError) {
      console.error('‚ùå L·ªói khi th√™m d·ªØ li·ªáu m·∫´u:', sampleError.message);
    }
  } catch (error) {
    console.error('‚ùå MySQL k·∫øt n·ªëi th·∫•t b·∫°i:', error.message);
  }
})();

// H√†m th√™m d·ªØ li·ªáu m·∫´u n·∫øu ch∆∞a c√≥
async function insertSampleDataIfNeeded() {
  // Ki·ªÉm tra xem ƒë√£ c√≥ d·ªØ li·ªáu trong c√°c b·∫£ng ch∆∞a
  const [userCount] = await pool.query('SELECT COUNT(*) as count FROM User');
  const [planCount] = await pool.query('SELECT COUNT(*) as count FROM QuitSmokingPlan');
  const [appointmentCount] = await pool.query('SELECT COUNT(*) as count FROM Appointment');
  
  if (userCount[0].count > 0 && planCount[0].count > 0 && appointmentCount[0].count > 0) {
    console.log('ƒê√£ c√≥ d·ªØ li·ªáu trong c∆° s·ªü d·ªØ li·ªáu, kh√¥ng c·∫ßn th√™m d·ªØ li·ªáu m·∫´u');
    return;
  }
  
  console.log('Th√™m d·ªØ li·ªáu m·∫´u v√†o c∆° s·ªü d·ªØ li·ªáu ƒë·ªÉ test...');
  
  // ƒê·∫£m b·∫£o ƒë√£ c√≥ Role
  await pool.query(`
    INSERT IGNORE INTO Role (RoleID, RoleName, Description)
    VALUES 
    (1, 'Admin', 'Administrator with full access'),
    (2, 'Coach', 'Smoking cessation coach'),
    (3, 'Smoker', 'Regular user trying to quit')
  `);
  
  // Th√™m ng∆∞·ªùi d√πng m·∫´u n·∫øu ch∆∞a c√≥
  if (userCount[0].count === 0) {
    // M·∫≠t kh·∫©u m·∫´u: 12345
    const hashedPassword = await bcrypt.hash('12345', 10);
    
    await pool.query(`
      INSERT INTO User (Name, Email, Password, Age, Gender, Phone, RoleID, Membership, IsActive, RegisterDate)
      VALUES 
      ('Admin User', 'admin@nosmoke.com', ?, 35, 'Male', '0901234567', 1, 'premium', 1, NOW()),
      ('Coach Example', 'coach@nosmoke.com', ?, 42, 'Female', '0909876543', 2, 'premium', 1, NOW()),
      ('Test User', 'user@nosmoke.com', ?, 28, 'Male', '0912345678', 3, 'free', 1, NOW())
    `, [hashedPassword, hashedPassword, hashedPassword]);
    
    console.log('‚úÖ ƒê√£ th√™m ng∆∞·ªùi d√πng m·∫´u');
  }
  
  // Th√™m k·∫ø ho·∫°ch cai thu·ªëc n·∫øu ch∆∞a c√≥
  if (planCount[0].count === 0) {
    await pool.query(`
      INSERT INTO QuitSmokingPlan (UserID, Title, Reason, StartDate, ExpectedQuitDate, Description, Status, SuccessRate)
      VALUES 
      (3, 'K·∫ø ho·∫°ch cai thu·ªëc 30 ng√†y', 'V√¨ s·ª©c kh·ªèe v√† gia ƒë√¨nh', CURRENT_DATE, DATE_ADD(CURRENT_DATE, INTERVAL 30 DAY), 'K·∫ø ho·∫°ch t·ª´ng b∆∞·ªõc gi·∫£m s·ªë ƒëi·∫øu thu·ªëc h√∫t m·ªói ng√†y trong 30 ng√†y', 'In Progress', 0),
      (3, 'K·∫ø ho·∫°ch ng·ª´ng ƒë·ªôt ng·ªôt', 'B√°c sƒ© khuy√™n ngh·ªã', DATE_SUB(CURRENT_DATE, INTERVAL 15 DAY), DATE_ADD(CURRENT_DATE, INTERVAL 15 DAY), 'D·ª´ng h√∫t thu·ªëc ho√†n to√†n t·ª´ ng√†y ƒë·∫ßu ti√™n', 'In Progress', 50)
    `);
    
    console.log('‚úÖ ƒê√£ th√™m k·∫ø ho·∫°ch cai thu·ªëc m·∫´u');
  }
  
  // Th√™m d·ªØ li·ªáu theo d√µi ti·∫øn tr√¨nh
  const [progressCount] = await pool.query('SELECT COUNT(*) as count FROM ProgressTracking');
  if (progressCount[0].count === 0) {
    await pool.query(`
      INSERT INTO ProgressTracking (PlanID, TrackingDate, Status, Note, CravingLevel)
      VALUES 
      (1, CURRENT_DATE, 'Good', 'Ng√†y ƒë·∫ßu ti√™n th·ª±c hi·ªán k·∫ø ho·∫°ch, gi·∫£m ƒë∆∞·ª£c 3 ƒëi·∫øu thu·ªëc', 7),
      (1, DATE_SUB(CURRENT_DATE, INTERVAL 1 DAY), 'Neutral', 'C·∫£m gi√°c th√®m thu·ªëc kh√° m·∫°nh nh∆∞ng c√≥ th·ªÉ ki·ªÉm so√°t', 8),
      (2, CURRENT_DATE, 'Struggling', 'C·∫£m th·∫•y kh√≥ khƒÉn khi ng·ª´ng ƒë·ªôt ng·ªôt', 9)
    `);
    
    console.log('‚úÖ ƒê√£ th√™m d·ªØ li·ªáu ti·∫øn tr√¨nh m·∫´u');
  }
  
  // Th√™m booking v√† appointment n·∫øu ch∆∞a c√≥
  if (appointmentCount[0].count === 0) {
    // Th√™m booking
    const [bookingResult] = await pool.query(`
      INSERT INTO Booking (UserID, CoachUserID, BookingDate, Status)
      VALUES (3, 2, NOW(), 'Approved')
    `);
    
    // Th√™m appointment
    await pool.query(`
      INSERT INTO Appointment (BookingID, AppointmentDate, DurationMinutes, Location, Notes, Status)
      VALUES (?, DATE_ADD(CURRENT_DATE, INTERVAL 3 DAY), 60, 'Online Meeting', 'Bu·ªïi t∆∞ v·∫•n ƒë·∫ßu ti√™n v·ªÅ k·∫ø ho·∫°ch cai thu·ªëc', 'Scheduled')
    `, [bookingResult.insertId]);
    
    console.log('‚úÖ ƒê√£ th√™m booking v√† appointment m·∫´u');
  }
}

// JWT Middleware
const verifyToken = (req, res, next) => {
  const token = req.header('Authorization')?.replace('Bearer ', '');
  
  if (!token) {
    return res.status(401).json({
      success: false,
      message: 'Kh√¥ng c√≥ token, quy·ªÅn truy c·∫≠p b·ªã t·ª´ ch·ªëi'
    });
  }

  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    res.status(401).json({
      success: false,
      message: 'Token kh√¥ng h·ª£p l·ªá'
    });
  }
};

// ====== ROOT ROUTES ======

app.get('/', (req, res) => {
  res.json({
    success: true,
    message: 'Quit Smoking Backend API v·ªõi JWT',
    version: '1.0.0',
    endpoints: [
      'GET / - API info',
      'GET /health - Health check',
      'POST /api/auth/register - ƒêƒÉng k√Ω',
      'POST /api/auth/login - ƒêƒÉng nh·∫≠p',
      'GET /api/users - Danh s√°ch ng∆∞·ªùi d√πng',
      'GET /api/users/:id - Chi ti·∫øt ng∆∞·ªùi d√πng',
      'GET /api/plans - Danh s√°ch k·∫ø ho·∫°ch',
      'POST /api/plans - T·∫°o k·∫ø ho·∫°ch m·ªõi',
      'GET /api/appointments - Danh s√°ch cu·ªôc h·∫πn',
      'POST /api/appointments - T·∫°o cu·ªôc h·∫πn',
      'GET /api/progress/:userId - Ti·∫øn tr√¨nh ng∆∞·ªùi d√πng',
      'POST /api/progress - C·∫≠p nh·∫≠t ti·∫øn tr√¨nh'
    ]
  });
});

app.get('/health', async (req, res) => {
  try {
    await pool.query('SELECT 1');
    res.json({
      success: true,
      message: 'Server v√† database ho·∫°t ƒë·ªông t·ªët!',
      database: 'MySQL connected',
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Database error',
      error: error.message
    });
  }
});

// ====== AUTH ROUTES ======

// Register
app.post('/api/auth/register', async (req, res) => {
  try {
    const { name, email, password, age, gender, phone } = req.body;
    
    // Check if user exists
    const [existingUsers] = await pool.query('SELECT Email FROM User WHERE Email = ?', [email]);
    if (existingUsers.length > 0) {
      return res.status(400).json({
        success: false,
        message: 'Email ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng'
      });
    }
    
    // Hash password
    const saltRounds = 10;
    const hashedPassword = await bcrypt.hash(password, saltRounds);
    
    // Get Smoker role ID
    const [roles] = await pool.query('SELECT RoleID FROM Role WHERE RoleName = "Smoker"');
    const roleId = roles[0]?.RoleID || 3;
    
    // Insert user
    const [result] = await pool.query(`
      INSERT INTO User (Name, Email, Password, Age, Gender, Phone, RoleID, Membership, IsActive, RegisterDate) 
      VALUES (?, ?, ?, ?, ?, ?, ?, 'free', 1, NOW())
    `, [name, email, hashedPassword, age || null, gender || null, phone || null, roleId]);
    
    res.status(201).json({
      success: true,
      message: 'ƒêƒÉng k√Ω th√†nh c√¥ng',
      userId: result.insertId
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'L·ªói ƒëƒÉng k√Ω',
      error: error.message
    });
  }
});

// Login
app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // Find user
    const [users] = await pool.query(`
      SELECT u.UserID, u.Name, u.Email, u.Password, u.Membership, r.RoleName
      FROM User u
      JOIN Role r ON u.RoleID = r.RoleID
      WHERE u.Email = ? AND u.IsActive = 1
    `, [email]);
    
    if (users.length === 0) {
      return res.status(401).json({
        success: false,
        message: 'Email ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng'
      });
    }
    
    const user = users[0];
    
    // Check password
    const validPassword = await bcrypt.compare(password, user.Password);
    if (!validPassword) {
      return res.status(401).json({
        success: false,
        message: 'Email ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng'
      });
    }
    
    // Generate JWT token
    const token = jwt.sign(
      { 
        userId: user.UserID, 
        email: user.Email, 
        role: user.RoleName,
        membership: user.Membership 
      },
      JWT_SECRET,
      { expiresIn: '7d' }
    );
    
    // Update last login
    await pool.query('UPDATE User SET LastLogin = NOW() WHERE UserID = ?', [user.UserID]);
    
    // Remove password from response
    delete user.Password;
    
    res.json({
      success: true,
      message: 'ƒêƒÉng nh·∫≠p th√†nh c√¥ng',
      token: token,
      user: user
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'L·ªói ƒëƒÉng nh·∫≠p',
      error: error.message
    });
  }
});

// ====== USER ROUTES ======

// DEBUG endpoint - Get all users (no auth required - only for testing)
app.get('/api/users/debug/all', async (req, res) => {
  try {
    const [users] = await pool.query(`
      SELECT u.UserID, u.Name, u.Email, u.Age, u.Gender, u.Phone, 
             u.RegisterDate, u.Membership, u.IsActive, r.RoleName 
      FROM User u
      JOIN Role r ON u.RoleID = r.RoleID
      ORDER BY u.RegisterDate DESC
    `);
    
    res.json({
      success: true,
      count: users.length,
      data: users
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'L·ªói l·∫•y danh s√°ch ng∆∞·ªùi d√πng',
      error: error.message
    });
  }
});

// Get all users (protected)
app.get('/api/users', verifyToken, async (req, res) => {
  try {
    const [users] = await pool.query(`
      SELECT u.UserID, u.Name, u.Email, u.Age, u.Gender, u.Phone, 
             u.RegisterDate, u.Membership, u.IsActive, r.RoleName 
      FROM User u
      JOIN Role r ON u.RoleID = r.RoleID
      WHERE u.IsActive = 1
      ORDER BY u.RegisterDate DESC
    `);
    
    res.json({
      success: true,
      count: users.length,
      data: users
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'L·ªói l·∫•y danh s√°ch ng∆∞·ªùi d√πng',
      error: error.message
    });
  }
});

// Get user by ID (protected)
app.get('/api/users/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;
    const [users] = await pool.query(`
      SELECT u.UserID, u.Name, u.Email, u.Age, u.Gender, u.Phone, 
             u.Address, u.RegisterDate, u.Membership, r.RoleName 
      FROM User u
      JOIN Role r ON u.RoleID = r.RoleID
      WHERE u.UserID = ? AND u.IsActive = 1
    `, [id]);
    
    if (users.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'
      });
    }
    
    res.json({
      success: true,
      data: users[0]
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'L·ªói l·∫•y th√¥ng tin ng∆∞·ªùi d√πng',
      error: error.message
    });
  }
});

// Get current user from token (protected)
app.get('/api/auth/me', verifyToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    
    const [users] = await pool.query(`
      SELECT u.UserID, u.Name, u.Email, u.Age, u.Gender, u.Phone, 
             u.Address, u.RegisterDate, u.Membership, r.RoleName 
      FROM User u
      JOIN Role r ON u.RoleID = r.RoleID
      WHERE u.UserID = ? AND u.IsActive = 1
    `, [userId]);
    
    if (users.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'
      });
    }
    
    res.json({
      success: true,
      data: users[0]
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'L·ªói l·∫•y th√¥ng tin ng∆∞·ªùi d√πng hi·ªán t·∫°i',
      error: error.message
    });
  }
});

// Update user information (protected)
app.put('/api/users/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.userId;
    
    // ƒê·∫£m b·∫£o ng∆∞·ªùi d√πng ch·ªâ c√≥ th·ªÉ c·∫≠p nh·∫≠t th√¥ng tin c·ªßa ch√≠nh h·ªç ho·∫∑c l√† admin
    if (parseInt(id) !== userId && req.user.role !== 'Admin') {
      return res.status(403).json({
        success: false,
        message: 'B·∫°n kh√¥ng c√≥ quy·ªÅn c·∫≠p nh·∫≠t th√¥ng tin c·ªßa ng∆∞·ªùi d√πng kh√°c'
      });
    }
    
    // Extract updatable fields
    const { name, age, gender, phone, address, membership } = req.body;
    
    // Validate membership if provided
    if (membership && !['free', 'premium', 'pro'].includes(membership)) {
      return res.status(400).json({
        success: false,
        message: 'Membership kh√¥ng h·ª£p l·ªá'
      });
    }
    
    // Build update query dynamically based on provided fields
    const updateFields = [];
    const updateValues = [];
    
    if (name !== undefined) {
      updateFields.push('Name = ?');
      updateValues.push(name);
    }
    
    if (age !== undefined) {
      updateFields.push('Age = ?');
      updateValues.push(age);
    }
    
    if (gender !== undefined) {
      updateFields.push('Gender = ?');
      updateValues.push(gender);
    }
    
    if (phone !== undefined) {
      updateFields.push('Phone = ?');
      updateValues.push(phone);
    }
    
    if (address !== undefined) {
      updateFields.push('Address = ?');
      updateValues.push(address);
    }
    
    if (membership !== undefined) {
      updateFields.push('Membership = ?');
      updateValues.push(membership);
    }
    
    // Exit if nothing to update
    if (updateFields.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Kh√¥ng c√≥ tr∆∞·ªùng n√†o ƒë∆∞·ª£c c·∫≠p nh·∫≠t'
      });
    }
    
    // Complete the query
    const updateQuery = `
      UPDATE User 
      SET ${updateFields.join(', ')} 
      WHERE UserID = ?
    `;
    
    // Execute the update
    await pool.query(updateQuery, [...updateValues, id]);
    
    // Get updated user info
    const [updatedUsers] = await pool.query(`
      SELECT UserID, Name, Email, Age, Gender, Phone, Address, Membership, RegisterDate
      FROM User
      WHERE UserID = ?
    `, [id]);
    
    if (updatedUsers.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng sau khi c·∫≠p nh·∫≠t'
      });
    }
    
    res.json({
      success: true,
      message: 'C·∫≠p nh·∫≠t th√¥ng tin ng∆∞·ªùi d√πng th√†nh c√¥ng',
      data: updatedUsers[0]
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'L·ªói c·∫≠p nh·∫≠t th√¥ng tin ng∆∞·ªùi d√πng',
      error: error.message
    });
  }
});

// ====== QUIT PLAN ROUTES ======

// Get all quit plans
app.get('/api/plans', async (req, res) => {
  try {
    const [plans] = await pool.query(`
      SELECT qsp.PlanID, qsp.Title, qsp.Reason, qsp.StartDate, qsp.ExpectedQuitDate,
             qsp.Description, qsp.Status, qsp.SuccessRate, u.Name as CreatorName
      FROM QuitSmokingPlan qsp
      LEFT JOIN User u ON qsp.UserID = u.UserID
      ORDER BY qsp.StartDate DESC
    `);
    
    res.json({
      success: true,
      count: plans.length,
      data: plans
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'L·ªói l·∫•y danh s√°ch k·∫ø ho·∫°ch',
      error: error.message
    });
  }
});

// Create new quit plan (protected)
app.post('/api/plans', verifyToken, async (req, res) => {
  try {
    const { title, reason, startDate, expectedQuitDate, description } = req.body;
    const userId = req.user.userId;
    
    const [result] = await pool.query(`
      INSERT INTO QuitSmokingPlan (UserID, Title, Reason, StartDate, ExpectedQuitDate, Description, Status)
      VALUES (?, ?, ?, ?, ?, ?, 'In Progress')
    `, [userId, title, reason, startDate, expectedQuitDate, description]);
    
    res.status(201).json({
      success: true,
      message: 'T·∫°o k·∫ø ho·∫°ch th√†nh c√¥ng',
      planId: result.insertId
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'L·ªói t·∫°o k·∫ø ho·∫°ch',
      error: error.message
    });
  }
});

// ====== APPOINTMENT ROUTES ======

// Get appointments (protected)
app.get('/api/appointments', verifyToken, async (req, res) => {
  try {
    const [appointments] = await pool.query(`
      SELECT a.AppointmentID, a.AppointmentDate, a.DurationMinutes, a.Location, a.Notes, a.Status,
             b.BookingID, u.Name as UserName, c.Name as CoachName
      FROM Appointment a
      JOIN Booking b ON a.BookingID = b.BookingID
      JOIN User u ON b.UserID = u.UserID
      JOIN User c ON b.CoachUserID = c.UserID
      ORDER BY a.AppointmentDate DESC
    `);
    
    res.json({
      success: true,
      count: appointments.length,
      data: appointments
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'L·ªói l·∫•y danh s√°ch cu·ªôc h·∫πn',
      error: error.message
    });
  }
});

// Create appointment (protected)
app.post('/api/appointments', verifyToken, async (req, res) => {
  try {
    const { coachId, appointmentDate, duration, location, notes } = req.body;
    const userId = req.user.userId;
    
    // First create a booking
    const [bookingResult] = await pool.query(`
      INSERT INTO Booking (UserID, CoachUserID, BookingDate, Status)
      VALUES (?, ?, NOW(), 'Approved')
    `, [userId, coachId]);
    
    // Then create the appointment
    const [appointmentResult] = await pool.query(`
      INSERT INTO Appointment (BookingID, AppointmentDate, DurationMinutes, Location, Notes, Status)
      VALUES (?, ?, ?, ?, ?, 'Scheduled')
    `, [bookingResult.insertId, appointmentDate, duration || 30, location || 'Online Meeting', notes]);
    
    res.status(201).json({
      success: true,
      message: 'T·∫°o cu·ªôc h·∫πn th√†nh c√¥ng',
      appointmentId: appointmentResult.insertId,
      bookingId: bookingResult.insertId
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'L·ªói t·∫°o cu·ªôc h·∫πn',
      error: error.message
    });
  }
});

// ====== PROGRESS ROUTES ======

// Get all progress entries 
app.get('/api/progress', async (req, res) => {
  try {
    const [progressEntries] = await pool.query(`
      SELECT pt.TrackingID, pt.PlanID, pt.TrackingDate, pt.Status, pt.Note, pt.CravingLevel,
             qsp.Title as PlanTitle, u.Name as UserName
      FROM ProgressTracking pt
      JOIN QuitSmokingPlan qsp ON pt.PlanID = qsp.PlanID
      JOIN User u ON qsp.UserID = u.UserID
      ORDER BY pt.TrackingDate DESC
      LIMIT 30
    `);
    
    res.json({
      success: true,
      count: progressEntries.length,
      data: progressEntries
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'L·ªói l·∫•y d·ªØ li·ªáu ti·∫øn tr√¨nh',
      error: error.message
    });
  }
});

// Get user progress (protected)
app.get('/api/progress/:userId', verifyToken, async (req, res) => {
  try {
    const { userId } = req.params;
    
    // L·∫•y c√°c QuitSmokingPlan c·ªßa ng∆∞·ªùi d√πng
    const [plans] = await pool.query(`
      SELECT PlanID FROM QuitSmokingPlan WHERE UserID = ?
    `, [userId]);
    
    if (plans.length === 0) {
      return res.json({
        success: true,
        count: 0,
        data: []
      });
    }
    
    // L·∫•y t·∫•t c·∫£ c√°c TrackingID cho t·∫•t c·∫£ c√°c plans c·ªßa ng∆∞·ªùi d√πng
    const planIds = plans.map(plan => plan.PlanID);
    const placeholders = planIds.map(() => '?').join(',');
    
    const [progressEntries] = await pool.query(`
      SELECT pt.TrackingID, pt.PlanID, pt.TrackingDate, pt.Status, pt.Note, pt.CravingLevel,
             qsp.Title as PlanTitle
      FROM ProgressTracking pt
      JOIN QuitSmokingPlan qsp ON pt.PlanID = qsp.PlanID
      WHERE pt.PlanID IN (${placeholders})
      ORDER BY pt.TrackingDate DESC
      LIMIT 30
    `, [...planIds]);
    
    res.json({
      success: true,
      count: progressEntries.length,
      data: progressEntries
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'L·ªói l·∫•y ti·∫øn tr√¨nh',
      error: error.message
    });
  }
});

// Add progress entry (protected)
app.post('/api/progress', verifyToken, async (req, res) => {
  try {
    console.log('POST /api/progress - Request body:', req.body);
    console.log('User from token:', req.user);

    const { planId, status, note, cravingLevel } = req.body;
    const userId = req.user.userId;
    
    // Validate required fields
    if (!planId || !status) {
      return res.status(400).json({
        success: false,
        message: 'PlanId v√† status l√† b·∫Øt bu·ªôc'
      });
    }

    // Validate craving level
    if (cravingLevel !== undefined && (cravingLevel < 0 || cravingLevel > 10)) {
      return res.status(400).json({
        success: false,
        message: 'CravingLevel ph·∫£i t·ª´ 0 ƒë·∫øn 10'
      });
    }
    
    // DEBUG: Hi·ªÉn th·ªã t·∫•t c·∫£ k·∫ø ho·∫°ch trong database
    const [allPlans] = await pool.query(`SELECT PlanID, UserID FROM QuitSmokingPlan`);
    console.log('All plans in database:', allPlans);
    
    // Ki·ªÉm tra xem k·∫ø ho·∫°ch c√≥ t·ªìn t·∫°i kh√¥ng
    const [plans] = await pool.query(`
      SELECT PlanID, UserID FROM QuitSmokingPlan 
      WHERE PlanID = ?
    `, [planId]);
    
    console.log('Found plans matching ID:', plans);
    
    if (plans.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Kh√¥ng t√¨m th·∫•y k·∫ø ho·∫°ch v·ªõi ID n√†y'
      });
    }

    // Ki·ªÉm tra xem k·∫ø ho·∫°ch c√≥ thu·ªôc user kh√¥ng
    if (parseInt(plans[0].UserID) !== parseInt(userId)) {
      console.log(`Plan owner ID (${plans[0].UserID}) does not match user ID (${userId})`);
      return res.status(403).json({
        success: false,
        message: 'B·∫°n kh√¥ng c√≥ quy·ªÅn c·∫≠p nh·∫≠t ti·∫øn tr√¨nh cho k·∫ø ho·∫°ch n√†y'
      });
    }
    
    const [result] = await pool.query(`
      INSERT INTO ProgressTracking (PlanID, TrackingDate, Status, Note, CravingLevel)
      VALUES (?, CURRENT_DATE, ?, ?, ?)
    `, [planId, status, note || null, cravingLevel || null]);
    
    console.log('Progress tracking created:', result);
    
    res.status(201).json({
      success: true,
      message: 'C·∫≠p nh·∫≠t ti·∫øn tr√¨nh th√†nh c√¥ng',
      trackingId: result.insertId
    });
  } catch (error) {
    console.error('Progress tracking error:', error);
    res.status(500).json({
      success: false,
      message: 'L·ªói c·∫≠p nh·∫≠t ti·∫øn tr√¨nh',
      error: error.message
    });
  }
});

// Test progress entry (no auth required - for testing)
app.post('/api/progress/test', async (req, res) => {
  try {
    const { planId, status, note, cravingLevel } = req.body;
    console.log('POST /api/progress/test - Request body:', req.body);

    // Validate required fields
    if (!planId || !status) {
      return res.status(400).json({
        success: false,
        message: 'PlanId v√† status l√† b·∫Øt bu·ªôc'
      });
    }
    
    // Ki·ªÉm tra xem k·∫ø ho·∫°ch c√≥ t·ªìn t·∫°i kh√¥ng
    const [plans] = await pool.query(`
      SELECT PlanID, UserID FROM QuitSmokingPlan 
      WHERE PlanID = ?
    `, [planId]);
    
    console.log('Found plans for test:', plans);
    
    if (plans.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Kh√¥ng t√¨m th·∫•y k·∫ø ho·∫°ch v·ªõi ID n√†y'
      });
    }
    
    const [result] = await pool.query(`
      INSERT INTO ProgressTracking (PlanID, TrackingDate, Status, Note, CravingLevel)
      VALUES (?, CURRENT_DATE, ?, ?, ?)
    `, [planId, status, note || null, cravingLevel || null]);
    
    res.status(201).json({
      success: true,
      message: 'C·∫≠p nh·∫≠t ti·∫øn tr√¨nh th√†nh c√¥ng (test)',
      trackingId: result.insertId
    });
  } catch (error) {
    console.error('Test progress tracking error:', error);
    res.status(500).json({
      success: false,
      message: 'L·ªói c·∫≠p nh·∫≠t ti·∫øn tr√¨nh (test)',
      error: error.message
    });
  }
});

// Start server
app.listen(PORT, () => {
  console.log(`
üöÄ Backend API Server v·ªõi JWT ƒëang ch·∫°y!
üìç Port: ${PORT}
üåê URL: http://localhost:${PORT}
üìä Health: http://localhost:${PORT}/health
üîê Auth: http://localhost:${PORT}/api/auth/login
üë• Users: http://localhost:${PORT}/api/users
üìã Plans: http://localhost:${PORT}/api/plans
üìÖ Appointments: http://localhost:${PORT}/api/appointments
üìà Progress: http://localhost:${PORT}/api/progress/:userId
  `);
});
